https://blog.csdn.net/leonwei/article/details/79298381
TBDR 和 TBR 的区别
在设计了TBR后，移动端gpu接受cpu的绘制指令后的绘制行为其实完全改变掉了。在tbr的架构上，是不能够来一个commandbuffer就执行一个的，那是噩梦，因为任何一个commandbuffer都可能影响到到整个FrameBuffer，如果来一个画一个，那么gpu可能会在每一个drawcall上都来回搬迁所有的Tile。这太慢了！所以TBR一般的实现策略是对于cpu过来的commandbuffer，只对他们做vetex process，然后对vs产生的结果暂时保存，等待非得刷新整个FrameBuffer的时候，才真正的随这批绘制做光栅化，做tile-based-rendering。什么是非得刷新整个FrameBuffer的时候？比如Swap Back and Front Buffer，glflush，glfinish，glreadpixels，glcopytexiamge，glbitframebuffer，queryingocclusion，unbind the framebuffer..总之是所有gpu觉得不得不把这块fb绘制好的时候。
TBR的管线上在PixelShader之前增多了一个步骤，即vs和gs处理后的数据（这里叫做FrameData）被暂时保存下来排好队，然后后面再对framebuffer分块，然后对每一块，绘制所有影响这个块的pixel。

既然tbr上是等待所有的framedata数据一起绘制pixel的，那么gpu就又多了一个优化的可能，deffered rendering，现有的大部分tbr的显卡都或多或少做了这个优化，例如ios的powervr，它多了一个叫做ISR的硬件，专门对这些framedata做处理，找到这次渲染真正有可能会被写入到Framebuffer上的那些drawcall，而过滤掉大部分的drawcall。

所以其实在power vr上对不透明物体的排序是没有太大意义的，而early-z这种策略也是不存在ios上的。）看，硬件巧妙的利用tbr的framedata队列实现了一种延迟渲染，即尽可能只渲染那些最终影响fb的物体，和软件层面的延迟渲染不同的是，软件层面的延迟渲染是针对一个drawcall的，对于从后到前的不透明物体绘制是每次都会绘制的，而硬件层面的延迟渲染时对一批drawcall的，它会从这批绘制里面找到最终要绘制的物体。所以现在大部分的移动端的gpu可以被称为TBDR架构。
